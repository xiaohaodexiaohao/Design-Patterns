# Design-Patterns
设计模式
## 设计模式的六大原则简述

#### ***单一职责原则***

- **定义**：一个类只负责一项职责
- **解决的问题：**防止当一个类负责两个职责的时候，当修改一个职责的同时，有可能会导致另一个正常运行的职责出现问题。

#### ***里氏替换原则***

- **定义**：所有引用基类的地方必须能透明的使用其子类的对象。
-  **解决的问题**：一个类A本有一个功能p1，先将功能p1进行扩展，扩展后的功能为p，p由原有的功能p1和新功能p2组成，新功能p由类A的子类B来完成，则子类B在完成新功能p2的同时，有可能会导致原有的功能p1发生故障。
-  **解决方案**：类B继承类A时，除添加新的方法完成新功能p2之外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
- *通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能*。
  1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  2. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入更加宽松。
  3. 当子类的方法实现了父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

#### ***依赖倒置原则***

- **定义**：高层模块不应该依赖底层模块，二者都应该依赖其抽象。
-  **解决问题：**类A直接依赖B，假如要将A改为依赖B，则必须通过修改A的代码来实现（比如A继承B，现需要实现B功能，就需要改A类继承B）。而A类一般是高层模块负责复杂的业务逻辑，如果修改类A，就会给程序带来不必要的风险。
-    **解决方案：**将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。
-   **说明**：Demo：*https://github.com/xiaohaodexiaohao/Design-Patterns*   核心思想就是面向接口编程

#### ***接口隔离原则***

-   **定义**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
-   **解决问题**：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
- **解决方案**：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少

#### ***迪米特法则***

- **定义**：一个对象应该对其他对象保持最少的了解。（也叫最少知道原则）
-   **解决问题：**类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
- **解决方案：**对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。

​    

#### ***开闭原则***

- **定义**：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- **解决问题**：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
- **解决方案：**当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。



## 常见的设计模式简述

#### 简单工厂模式

- 问题场景：在Java中要得到一个对象最简单的办法就是直接new一个对象，比如:A a = new A(); 那么需要在10个类中用到，我们就要在这10个不同的类中new A()，如果有一天因为某些原因需要将A类名改为B，那么我们就需要在这10个类中一一去改，这样麻烦又容易出错。这个时候就可以用到工厂模式，其实它就是对new A（）再做了一层封装，只需要调用工厂模式提供的方法去得到对象，具体的new 操作放到了背后。

#### 单例模式

- 问题场景：单例模式，顾名思义，在程序运行时有且仅有一个实例存在。最常见的一个应用场景就是网站访问量的计数器，试想如果允许创建多个实例，那还怎么计数，这个时候就得创建有且仅有的一个实例了。如何防止程序创建多个实例呢？首先就是不能直接new。不能new那就是要将构造函数实例化，对外提供一个方法来获取这个对象。
- 几种实现单例模式的方法。

#### 适配器模式

- 问题场景：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不[兼容](https://baike.baidu.com/item/%E5%85%BC%E5%AE%B9)而不能一起工作的那些类可以一起工作。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。

#### 责任链模式

- 问题场景：将接收者对象连成一条链条，并在该链上传递请求，直到有一个接收者对象处理它。通过让更多对象有机会处理请求，避免了请求发送者和接收者之间的耦合。比如在公司请假过程中，一般会有组长，部门经理，总监等等，如果组长不能批准就会一层一层的传到上一级，知道找到合适的人对这个请求进行处理。
